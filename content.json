{"meta":{"title":"My blog","subtitle":"","description":"My blog","author":"John Doe","url":"http://blog.MIkuti.com","root":"/"},"pages":[{"title":"","date":"2022-05-21T14:18:33.301Z","updated":"2022-05-21T14:18:33.301Z","comments":true,"path":"vx.json","permalink":"http://blog.mikuti.com/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"23\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"Markdown 基本语法.md\",\"signature\":\"84689818285241\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"31\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"分析报告.md\",\"signature\":\"110240578729145\",\"tags\":[]},{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"33\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"病毒分析报告.md\",\"signature\":\"73166421030073\",\"tags\":[]}],\"folders\":[{\"name\":\"_posts\"},{\"name\":\"about\"},{\"name\":\"categories\"},{\"name\":\"contributors\"},{\"name\":\"examples\"},{\"name\":\"faqs\"},{\"name\":\"friends\"},{\"name\":\"mylist\"},{\"name\":\"tags\"},{\"name\":\"v4\"},{\"name\":\"病毒分析报告.assets\"}],\"id\":\"1\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"49299287766201\",\"version\":3}"},{"title":"","date":"2022-05-19T15:38:13.376Z","updated":"2022-05-19T15:38:13.376Z","comments":true,"path":"分析报告.html","permalink":"http://blog.mikuti.com/%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.html","excerpt":"","text":""},{"title":"","date":"2022-05-19T14:06:28.102Z","updated":"2022-05-11T03:46:02.000Z","comments":true,"path":"病毒分析报告.html","permalink":"http://blog.mikuti.com/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.html","excerpt":"","text":"病毒分析报告 运行平台 windows虚拟机 分析人 赵文强 分析时间 2022.04.28 1 样本概况1.1基本信息 文件: C:\\Users\\15PB\\Desktop\\sample\\1.exe 大小: 147968 bytes 修改时间: 2021年11月22日, 15:06:55 MD5: 939198AB85520F8FA042349EB83D64D1 SHA1: 3E8C0F7E6E55F5FECE2339EC9C4C52CF9270E582 SHA256 0c681fdfe86923929453a713de6b2bf30fabe979ca0130f8a0a75a77a5c015f6 SSDeep 3072:t+DIgZx6B1Bx4Megsbd26KkltYBw91mH67rc8Xw4vQobyU:Gz6BW7bw6ZlKBwnmHaotpSyU CRC32: F2727D9B 样本类型 PE32 executable (DLL) (GUI) Intel 80386, for MS Windows 编译信息 Microsoft Visual C++ ver. 6&#x2F;7 DLL 2021-11-15 [ Win Vista ] 加固情况 无加固 2 行为分析根据PE文件信息可知此文件为dll文件。第一次分析单个dll文件的病毒。查阅资料可知此类型病毒通常使用rundll32.exe来加载dll文件。 使用Rundll32.exe的标准语法 rundll32 第三个参数可以忽略，使用loadPE查看导出的入口函数为Control_RunDLL 运行程序加载dll病毒，使用火绒剑监控进程行为信息 2.1执行监控 除病毒自身dll’外程序还加载了comctl32.dll 2.2注册表行为 存在遍历注册表行为 创建了2个注册表 尝试删除网络代理设置失败 应该是设置了一些文件配置 2.3进程行为 检测到了一些敏感操作，但是并未显示出来 2.4网络行为 链接了以下的IP地址 3.基础分析3.1 sub3E8EC9 获取dllbase ​ 此函数通过FS【30】获取peb结构，然后获取InLoadOrderModuleList，链表InLoadOrderModuleList中按顺序存放着PE装入运行时初始化模块信息。找到想要的dll的结点后，在其基础上再偏移0x18就是dll在内存中的加载基地址 3.2 sub_3D251C dll名Hash算法 在Vs还原此段代码，尝试将”kernel32.dll”进行hash运算 和程序中结果一致 3.3 sub_3EA607 获得函数地址 根据kernel32.dll的加载基址根据PE文件偏移找到导出表，遍历导出表比对获得想要的函数地址并且返回 3.4 sub_3D2309 类似loadlibrary 获取函数地址 根据传入的 dll名的hash值以及函数名的hash值获取到函数地址并保存 3.5总结及后续分析思路过程中存在的调用都是通过Hash值来获取函数地址，再传参通过地址调用函数，IDA无法分析出函数的名字。可以通过Hash值对照Api的方式来确定到底调用了什么API 3.5.1思路一：通过OD等动态调试软件，在动态获取函数地址的地方下断点，编写OD脚本计录Hash值对应的函数名称，也可以手动记录。 优点：不需要手动实现算法 缺点：由于程序运行时不一定运行所有函数，获取到的记录不全。 不过也可以修改获取函数地址时的参数，将遇到的函数动态跑一遍来确定是什么API 3.5.2思路二：无法动态调试的情况下，可以通过还原Hash算法，将病毒常用的API进行求Hash，然后对比Hash对IDA中的函数进行备注 优点：可以获取到所有的记录，直接查询就行 缺点：可能有的算法非常复杂，不好手动实现。 4获取API4.1获取FunctionHash对照 通过动态调试，记录Hash值以及对应的名字。使用OD调试时直接进了DllEntryPoint而不是Control_RunDLL 。只使用到了极少部分的API。后面分析到哪里直接用改参数的方式获取API是什么了。 经验证，只需要改FunHash和DllHash就可以了，另外三个参数对获取API名字上并无影响。 0x9D19C04E对应的API未获取到，通过上下文以及参数分析，应该是HeapAlloc 4.2 Hash获取函数名算法实现由于动态运行获取到Api有限，并且将Hash手动该改参数的办法仍然获取不到函数APi，所以将算法拷出重新编写程序测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108int sub_3EAAD2(BYTE* a)&#123; BYTE* v1; int i; v1 = a; for (i = 0; *v1; ++v1) i = (i &lt;&lt; 16) + (i &lt;&lt; 6) + *v1 - i; return i;&#125;DWORD getHash(DWORD a1, WORD* a2) &#123; WORD* v2; unsigned int v3; int v5; v2 = a2; v5 = 0; if (*a2) &#123; do &#123; v3 = *v2; if (v3 &gt;= 0x41 &amp;&amp; v3 &lt;= 0x5A) v3 += 32; ++v2; v5 = (v5 &lt;&lt; 16) + (v5 &lt;&lt; 6) + v3 - v5; &#125; while (*v2); &#125; return v5;&#125;DWORD GetFun::getDllBase(DWORD dllHash)&#123; int* InLoadOrderModuleList; // edi@1 int i; // esi@1 InLoadOrderModuleList = (int*)(*(DWORD*)(__readfsdword(0x30) + 0xC) + 0xC); for (i = *InLoadOrderModuleList; ; i = *(DWORD*)i) &#123; // 通过fs:[30]获取到 Ldr ，ldr偏移0c获得InLoadOrderModuleList if ((int*)i == InLoadOrderModuleList) // InLoadOrderModuleList 最多使用的是断链隐藏dll return 0; // 返回dllbase模块基址 if ((getHash(0x54F2F, *(WORD**)(i + 0x30)) ^ 0x13EEA1A2) == dllHash)// 可能是判断模块名的hash break; &#125; // 返回dllbase 模块基址 return *(DWORD*)(i + 0x18);&#125;DWORD GetFun::getFunBase(DWORD funHash, DWORD dllBase)&#123; void* Fun_Base; // esi@1 unsigned int i; // ebx@1 unsigned int export_table; // edi@1 int ENT; // ecx@1 int funHash_; // [sp+18h] [bp-14h]@1 int ENT_1; // [sp+1Ch] [bp-10h]@1 int EOt; // [sp+20h] [bp-Ch]@1 int EAT; // [sp+24h] [bp-8h]@1 int NTheader; // [sp+28h] [bp-4h]@1 funHash_ = funHash; Fun_Base = 0; i = 0; NTheader = *(DWORD*)(dllBase + 0x3C); // 从加载基址算起，偏移0x3C的地方就是其PE头(又称NT头) export_table = dllBase + *(DWORD*)(NTheader + dllBase + 0x78);// PE头偏移0x78的地方存放着指向函数导出表的指针 EAT = dllBase + *(DWORD*)(export_table + 0x1C);// 导出地址表 ENT = dllBase + *(DWORD*)(export_table + 0x20);// 导出名称表 ENT_1 = dllBase + *(DWORD*)(export_table + 0x20); EOt = dllBase + *(DWORD*)(export_table + 0x24);// 导出序号表 while (i &lt; *(DWORD*)(export_table + 0x18)) &#123; if ((sub_3EAAD2((BYTE*)(dllBase + *(DWORD*)(ENT + 4 * i))) ^ 0x39709147) == funHash_)// 判断是否是传入的函数名hash &#123; printf(&quot;获取函数名成功\\t&quot;); printf(&quot;%s\\n&quot;, (dllBase + *(DWORD*)(ENT + 4 * i))); break;//打印函数名 &#125; ENT = ENT_1; ++i; &#125; // 返回获得的函数地址 return 0;&#125;void GetFun::getFun(DWORD funHash, DWORD dllHash)&#123; DWORD dllBase = getDllBase(dllHash); if (dllBase == 0) &#123; printf(&quot;%08X的dllBash获取失败\\n&quot;); return; &#125; getFunBase(funHash, dllBase);&#125;int main() &#123; DWORD fun[][2] = &#123; //&#123;0xF677E454,0xC0CF1A4&#125;, &#123;0xC0CF1A4,0xC0CF1A4&#125; &#125;; GetFun g; for (int i = 0; i &lt; 1; i++) &#123; printf(&quot;%08X\\t&quot;, fun[i][0]); g.getFun(fun[i][0], fun[i][1]); &#125; return 0;&#125; 测试运行成功，现在将未获取到的函数拿来跑一下 FunbHash 0xE44623FB DllBash 0xE44623FB 获取失败了 4.3获取程序所需库文件 在IDA查看LoadLibrary的交叉引用地址，只有一个地方使用到了，在OD中下断点，运行程序 在这个位置找到程序所需要的DLL，但是这里的空间属于堆空间，向上回溯寻找存储dll名字的地方。 程序在运行完这个函数之后栈中出现了dll名字，跟进这个函数中去 在其中发现了获取堆空间的函数。而存储dll名称的地址就是获取的堆空间地址。由于在IDA中并没有搜索到任何的dll名称字符串，所以应该是使用了加密存储。 在这里发现，dll名确实是经过解密后储存在堆空间里的。 每次解密使用的值存在ebx中，但是每次的EBX值是不一样的 回溯代码发现解密的密钥通过参数传入。 先快速的获得程序加载的dll dll名 0006F944 00226FB0 UNICODE “advapi32.dll” 0006F944 00226FB0 UNICODE “bcrypt.dll” 0006F944 00226FB0 UNICODE “crypt32.dll” 0006F944 00226FB0 UNICODE “shell32.dll” 0006F944 00226FB0 UNICODE “shlwapi.dll” 0006F944 00226FB0 UNICODE “urlmon.dll” 0006F944 00226FB0 UNICODE “userenv.dll” 0006F944 00226FB0 UNICODE “wininet.dll” 0006F944 001F17D8 UNICODE “wtsapi32.dll” 将出现的dll都加载进去，之前获取不到的APi能正常获取了 但是仍然有部分部的API没能获取，还是有DLL没有获取到， 想要获取程序加载的全部DLL，还要进一步分析解密。 4.4获取详细API将IDA中分析的代码函数名改为已经获取的函数名 由于某些API调用约定不同，和样本自身用的约定冲突，导致改完名字后IDA自动识别参数，导致堆栈不平衡，一些地方不能进行反编译。 5样本行为 最内层的循环通过局部变量V0来区分运行流程 包含了以下的行为 1：检索指定进程关联的远程桌面会话服务 2：获取计算机信息，硬盘信息 3：检索指定进程的信息 4：更改服务设置 5：创建进程 6：获取令牌权限复制令牌 7:获取模拟令牌并创建进程 8：创建线程 二层循环内是一些switch case的组合，可能是通过命令来进行控制，代码被改崩了，不好进去法分析。 其中包括创建线程检索文件信息 线程回调函数内容如下 加密解密操作： 该程序使用了Bcypt进行加密解密 应该是根据远程指令进行了一些文件操作 最下方的代码有一些命令行的操作 因能力有限以及时间原因，有很多内容没有分析到。 附1.部分Dll—Hash对照表 9C9047D0 Kernel32.dll C1C081B6 ntdll 主要看API的Hash对照，DLL简单记录了两个 附2.部分Function—Hash对照表 Hash值 对应API 7CE3458A memset 460FF9A9 GetCommandLIne 7D457EE2 GetProcessHeap 9D19C04E HeapAlloc CE482E70 GetModuleHandle 6E5DC294 RtlAllocateHeap 52F9059F HeapFree 8B1A77D6 ExitProcess 26585816 lstrlenA 87B84A40 GetCurrentProcessId D28F76AB ProcessIdToSessionId F2C3CBE2 GetComputerNameA FC0D3D9C GetVolumeInformationW 0x15859AD0 GetWindowDirectoryW 0xE5FA8414 _snprintf 0xBDE7009F CreateToolHelp32napshot 0xB41B9FB1 Process32NextW 0x2237D547 CloseHandle 0x1A63A552 Process32First 0xA4D486EE QueryFullProcessImageNameW 0x9C9047D0 OpenProcess 0xA0C07FEA GetSystemTimeA 0xBF8568A3 CreateProcessW 0x7B7E9E28 ESI&#x3D;75945767 (bcrypt.BCryptFinalizeKeyPair) 0xBF1573BE lstrcmpiA 0x237D845C WaitForSingleObject 0x576CCFEB GetCurrentProcess 0x7F201969 GetModuleFileNameW E65B2D45 ESI&#x3D;77A73C01 (kernel32.LoadLibraryW) FFE487CD ESI&#x3D;75942CDA (bcrypt.BCryptOpenAlgorithmProvider) 07B6A700 ESI&#x3D;75941E2E (bcrypt.BCryptGenRandom) 23BC8213 ESI&#x3D;75942391 (bcrypt.BCryptCloseAlgorithmProvider) 0B53DC03 ESI&#x3D;77DACA64 (advapi32.OpenSCManagerW) 24664522 ESI&#x3D;77DB369C (advapi32.CloseServiceHandle) 16FF8204 ESI&#x3D;76985708 (shell32.SHGetFolderPathW) 26585820 ESI&#x3D;77A6D9E8 (kernel32.lstrlenW) B8918EB7 ESI&#x3D;77A58BFA (kernel32.lstrcpyW) 6CFF1F7A ESI&#x3D;76919EE8 (shell32.CommandLineToArgvW) 0BA82970 ESI&#x3D;77A6CA64 (kernel32.LocalFree) B484D458 ESI&#x3D;77A6CC56 (kernel32.CreateFileW) 89E5D2AB ESI&#x3D;77A638AD (kernel32.GetFileInformationByHandleEx) 33AB2862 ESI&#x3D;77A659D7 (kernel32.OpenProcess) 769CC37E ESI&#x3D;77A73386 (kernel32.CreateEventW) 049F4D21 ESI&#x3D;77A7375D (kernel32.CreateThread) B8987DD1 ESI&#x3D;77C93CD6 (ntdll._snwprintf) DEF755BF ESI&#x3D;759456BE (bcrypt.BCryptGenerateKeyPair) 56B1EB58 ESI&#x3D;759450EF (bcrypt.BCryptExportKey) 04CD4E30 ESI&#x3D;77C94CC0 (ntdll.memcpy) 7096C78F ESI&#x3D;75944EE8 (bcrypt.BCryptImportKeyPair) 6F07F3C9 ESI&#x3D;7594554A (bcrypt.BCryptSecretAgreement) C61EF00B ESI&#x3D;759455F9 (bcrypt.BCryptDeriveKey) 6B491378 ESI&#x3D;75941CA7 (bcrypt.BCryptGetProperty) 83155FA9 ESI&#x3D;75944320 (bcrypt.BCryptImportKey) 41729979 ESI&#x3D;75945468 (bcrypt.BCryptDestroySecret) 8B316F96 ESI&#x3D;75941F40 (bcrypt.BCryptDestroyKey) 237D845C ESI&#x3D;77A6BA90 (kernel32.WaitForSingleObject) 4B286B55 ESI&#x3D;7620BB71 (shlwapi.PathFindFileNameW) 810611C3 ESI&#x3D;77A753B2 (kernel32.FindFirstFileW) 26585816 ESI&#x3D;77A6A611 (kernel32.lstrlenA) 1DDE758B ESI&#x3D;77CC65E3 (ntdll.RtlGetVersion) D07A82AD ESI&#x3D;77A5BE77 (kernel32.GetNativeSystemInfo) D28F76AB ESI&#x3D;77A6B744 (kernel32.ProcessIdToSessionId) 7CE3458A ESI&#x3D;77C95340 (ntdll.memset) A83477B1 ESI&#x3D;75941B93 (bcrypt.BCryptCreateHash) 8574C123 ESI&#x3D;75941B0B (bcrypt.BCryptHashData) 62807E6A ESI&#x3D;75941B44 (bcrypt.BCryptFinishHash) 760C955B ESI&#x3D;75941A5F (bcrypt.BCryptDestroyHash) 5ACF85FE ESI&#x3D;7594195C (bcrypt.BCryptEncrypt) 83E2C3FB ESI&#x3D;75E8A546 (crypt32.CryptBinaryToStringW) B325898B ESI&#x3D;76529197 (wininet.InternetOpenW) 3CFE7F69 ESI&#x3D;7652492C (wininet.InternetConnectW) B50C381D ESI&#x3D;76524A42 (wininet.HttpOpenRequestW) 9D3F5D46 ESI&#x3D;76517741 (wininet.InternetSetOptionW) BA397C5C ESI&#x3D;76517ED7 (wininet.InternetQueryOptionW) 6C1516BF ESI&#x3D;7652BA12 (wininet.HttpSendRequestW) 9D19C04E HeapAlloc"},{"title":"","date":"2022-05-21T14:18:33.167Z","updated":"2022-05-21T14:18:33.167Z","comments":true,"path":"about/vx.json","permalink":"http://blog.mikuti.com/about/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"12\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"index.md\",\"signature\":\"51292152591545\",\"tags\":[]}],\"folders\":[],\"id\":\"11\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"12865080194233\",\"version\":3}"},{"title":"","date":"2022-05-20T10:11:18.636Z","updated":"2022-05-20T10:11:18.636Z","comments":true,"path":"about/index.html","permalink":"http://blog.mikuti.com/about/index.html","excerpt":"","text":"ID:MIkuti 从事信息安全，以后这个小站用来记录学习笔记，和一些所见所闻 2020年中对网络安全渗透进行初步了解学习 在2020年末到2021年初从事过等保行业 2021年中旬在培训机构学习二进制安全 想从事病毒分析的工作"},{"title":"所有分类","date":"2022-05-20T10:16:13.397Z","updated":"2022-05-20T10:16:13.397Z","comments":true,"path":"categories/index.html","permalink":"http://blog.mikuti.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-21T14:18:33.177Z","updated":"2022-05-21T14:18:33.177Z","comments":true,"path":"categories/vx.json","permalink":"http://blog.mikuti.com/categories/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"14\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"index.md\",\"signature\":\"23349095363769\",\"tags\":[]}],\"folders\":[],\"id\":\"13\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"20733460280505\",\"version\":3}"},{"title":"contributors","date":"2022-05-19T00:54:16.000Z","updated":"2022-05-20T10:16:16.612Z","comments":true,"path":"contributors/index.html","permalink":"http://blog.mikuti.com/contributors/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-21T14:18:33.190Z","updated":"2022-05-21T14:18:33.190Z","comments":true,"path":"contributors/vx.json","permalink":"http://blog.mikuti.com/contributors/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"16\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"index.md\",\"signature\":\"62725355533497\",\"tags\":[]}],\"folders\":[],\"id\":\"15\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"139119938827449\",\"version\":3}"},{"title":"examples","date":"2022-05-19T00:53:40.000Z","updated":"2022-05-20T10:16:22.987Z","comments":true,"path":"examples/index.html","permalink":"http://blog.mikuti.com/examples/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-21T14:18:33.202Z","updated":"2022-05-21T14:18:33.202Z","comments":true,"path":"examples/vx.json","permalink":"http://blog.mikuti.com/examples/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"18\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"index.md\",\"signature\":\"658783139001\",\"tags\":[]}],\"folders\":[],\"id\":\"17\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"16760615531705\",\"version\":3}"},{"title":"我的朋友们","date":"2022-05-20T10:16:29.470Z","updated":"2022-05-20T10:16:29.470Z","comments":true,"path":"friends/index.html","permalink":"http://blog.mikuti.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2022-05-21T14:18:33.228Z","updated":"2022-05-21T14:18:33.228Z","comments":true,"path":"friends/vx.json","permalink":"http://blog.mikuti.com/friends/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"22\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"index.md\",\"signature\":\"80386261054649\",\"tags\":[]}],\"folders\":[],\"id\":\"21\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"74824278406329\",\"version\":3}"},{"title":"faqs","date":"2022-05-19T00:52:49.000Z","updated":"2022-05-19T00:52:49.849Z","comments":true,"path":"faqs/index.html","permalink":"http://blog.mikuti.com/faqs/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-21T14:18:33.216Z","updated":"2022-05-21T14:18:33.216Z","comments":true,"path":"faqs/vx.json","permalink":"http://blog.mikuti.com/faqs/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"20\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"index.md\",\"signature\":\"53181938201785\",\"tags\":[]}],\"folders\":[],\"id\":\"19\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"1255783593145\",\"version\":3}"},{"title":"所有标签","date":"2022-05-18T15:29:09.904Z","updated":"2022-05-18T15:29:09.904Z","comments":true,"path":"tags/index.html","permalink":"http://blog.mikuti.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-21T14:18:33.263Z","updated":"2022-05-21T14:18:33.263Z","comments":true,"path":"tags/vx.json","permalink":"http://blog.mikuti.com/tags/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"27\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"index.md\",\"signature\":\"63442615071929\",\"tags\":[]}],\"folders\":[],\"id\":\"26\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"93314112615609\",\"version\":3}"},{"title":"","date":"2022-05-21T14:18:33.272Z","updated":"2022-05-21T14:18:33.272Z","comments":true,"path":"v4/vx.json","permalink":"http://blog.mikuti.com/v4/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[],\"folders\":[{\"name\":\"getting-started\"}],\"id\":\"28\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"49556985803961\",\"version\":3}"},{"title":"","date":"2022-05-21T14:18:33.251Z","updated":"2022-05-21T14:18:33.251Z","comments":true,"path":"mylist/vx.json","permalink":"http://blog.mikuti.com/mylist/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"25\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"index.md\",\"signature\":\"23396340004025\",\"tags\":[]}],\"folders\":[],\"id\":\"24\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"85450027496633\",\"version\":3}"},{"title":"","date":"2022-05-21T14:18:33.082Z","updated":"2022-05-21T14:18:33.082Z","comments":true,"path":"vx_notebook/vx_notebook.json","permalink":"http://blog.mikuti.com/vx_notebook/vx_notebook.json","excerpt":"","text":"{\"attachment_folder\":\"vx_attachments\",\"config_mgr\":\"vx.vnotex\",\"created_time\":\"2022-05-21T14:18:33Z\",\"description\":\"\",\"extra_configs\":{},\"history\":[],\"image_folder\":\"vx_images\",\"name\":\"source\",\"tag_graph\":\"\",\"version\":3,\"version_controller\":\"dummy.vnotex\"}"},{"title":"","date":"2022-05-18T15:27:34.983Z","updated":"2022-05-18T15:27:34.983Z","comments":true,"path":"mylist/index.html","permalink":"http://blog.mikuti.com/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-21T14:18:33.291Z","updated":"2022-05-21T14:18:33.291Z","comments":true,"path":"病毒分析报告.assets/vx.json","permalink":"http://blog.mikuti.com/%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.assets/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[],\"folders\":[],\"id\":\"32\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"112954998060217\",\"version\":3}"},{"title":"文档","date":"2022-05-19T00:55:17.000Z","updated":"2022-05-19T15:45:32.720Z","comments":true,"path":"v4/getting-started/index.html","permalink":"http://blog.mikuti.com/v4/getting-started/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-21T14:18:33.280Z","updated":"2022-05-21T14:18:33.280Z","comments":true,"path":"v4/getting-started/vx.json","permalink":"http://blog.mikuti.com/v4/getting-started/vx.json","excerpt":"","text":"{\"created_time\":\"2022-05-21T14:18:33Z\",\"files\":[{\"attachment_folder\":\"\",\"created_time\":\"2022-05-21T14:18:33Z\",\"id\":\"30\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"name\":\"index.md\",\"signature\":\"85523041940665\",\"tags\":[]}],\"folders\":[],\"id\":\"29\",\"modified_time\":\"2022-05-21T14:18:33Z\",\"signature\":\"8028947018937\",\"version\":3}"}],"posts":[{"title":"FTP FUzzing工具原理与应用","slug":"安全/二进制安全工具/FTP FUzzing工具原理与应用","date":"2022-05-22T09:05:06.000Z","updated":"2022-05-22T10:00:05.914Z","comments":true,"path":"2022/05/22/安全/二进制安全工具/FTP FUzzing工具原理与应用/","link":"","permalink":"http://blog.mikuti.com/2022/05/22/%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/FTP%20FUzzing%E5%B7%A5%E5%85%B7%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/","excerpt":"","text":"FTP协议介绍 FTP协议，即文件传输协议FTP（File Transfer Protocol）是因特网中使用最广泛的文件传输协议。 FTP的传出有两种方式：ASCII、二进制。 FTP是一个8位的客户端-服务器协议，能操作任何类型的文件而不需要进一步处理，就像MIME或Unicode一样。 但是，FTP有着极高的延时，这意味着，从开始请求到第一次接收需求数据之间的时间，会非常长；并且不时的必须执行一些冗长的登录进程。 FTP协议常用命令 常用指令 功能说明 USER 用户名 PASS 密码 CWD 改变服务器上的工作目录 RETR 从服务器上找回(复制)文件 RMD 在服务器上删除指定目录 RNTO 对新路径重命名 HELP 返回指定命令信息 工具原理与使用 模拟FTP常用的命令 发送不同长度的命令 递增不长可以设置（Fuzzing粒度） 发送速度可以调整（Fuzzing速度） 测试不同的方式","categories":[{"name":"安全","slug":"安全","permalink":"http://blog.mikuti.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"二进制安全工具","slug":"安全/二进制安全工具","permalink":"http://blog.mikuti.com/categories/%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"FTP Fuzzing","slug":"FTP-Fuzzing","permalink":"http://blog.mikuti.com/tags/FTP-Fuzzing/"},{"name":"Fuzzg","slug":"Fuzzg","permalink":"http://blog.mikuti.com/tags/Fuzzg/"}]},{"title":"WinDbg使用教程","slug":"安全/二进制安全工具/WinDbg使用","date":"2022-05-22T09:05:06.000Z","updated":"2022-05-22T10:38:12.081Z","comments":true,"path":"2022/05/22/安全/二进制安全工具/WinDbg使用/","link":"","permalink":"http://blog.mikuti.com/2022/05/22/%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/WinDbg%E4%BD%BF%E7%94%A8/","excerpt":"","text":"建立调试会话用户层程序调试会话的建立 直接创建一个进程,并调试它：File-&gt;Open Executable 附加到已经打开的进程：File-&gt;Attatch to a Process 通过Noninvasive设置侵入、非侵入式，默认不勾选侵入式 侵入式附加：接管正在运行的进程，可以进行调试 非侵入式附加：只是能够读取进程信息，不能接收目标进程的调试事件 内核调试会话的建立概述 正常我们是无法用自己的系统去调试自己的操作系统的，我们都需要知道调试器是要下断点的，假如我们中断了自己的操作系统，那么我们不是什么都做不了了吗，所以一般我们调试内核，都是用一台机器调试另外一台机器。 使用两台机器过于繁琐，我们可以使用物理机器调试虚拟机，建立双机调试环境。 类似于用户层非侵入式的调试，我们是可以不接管本系统的调试仅仅查看本系统内核中的信息，这种方式叫做本地内核调试 使用虚拟机进行双机内核调试建立 虚拟机进行双机内核调试有多种连接方式，其中我们使用VirtualKD工具来辅助创建双机调试环境。需要：Windbg、虚拟机、VirtualKD 本地内核调试 本地内核调试不是真正的调试，只是查看信息而已，故而调试相关的命令都是受限的。 必要条件需要是调试模式启动的windows操作系统需要以管理员方式运行windbg操作系统与windbg版本需要对应 | 以调试模式启动Windows启动WinDbg点击File-&gt;Kernel Debug-&gt;Local-&gt;确定 WinDbg的界面预览菜单与工具栏 File菜单、Edit菜单、View菜单、Debug菜单、Vindow菜单、Help菜单 调试菜单组 视图菜单组","categories":[{"name":"安全","slug":"安全","permalink":"http://blog.mikuti.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"二进制安全工具","slug":"安全/二进制安全工具","permalink":"http://blog.mikuti.com/categories/%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"WinDbg","slug":"WinDbg","permalink":"http://blog.mikuti.com/tags/WinDbg/"}]},{"title":"测试","slug":"测试","date":"2022-05-18T15:45:06.000Z","updated":"2022-05-23T03:13:40.630Z","comments":true,"path":"2022/05/18/测试/","link":"","permalink":"http://blog.mikuti.com/2022/05/18/%E6%B5%8B%E8%AF%95/","excerpt":"","text":"测试父子分类 测试多标签 前言在很多情况下，我们希望在 Hexo 中写的一篇文章能够同时属于多个分类，例如我写了一篇《Webpack 的 Chunk.id 是怎么来的》，我既想将放在 前端知多少 这个分类下，又想将它放在 Webpack 专场 这个分类。 按照官方的解释，categories 这个选项有两种配置方法（其实有三种）。那我们就来讲讲这三种配置方法。 子分类下面的分类配置会将该文章放到 Sports/Baseball 这个分类下。 123categories: - Sports - Baseball 同样的作用还可以这样写： 1categories: [Sports,Baseball] 上面两种写法最终的效果都是一样的，都是将文章放在了一个子分类目录下。 多个分类如果我们的要求是将文章同时分到两个或者多个不同的类目下呢？官方给出的方法是： 123categories: - [Sports] - [Baseball] 只需要用中括号将独立的分类括起来即可，这样上面的文章就会被分类在 Sports 和 Baseball 这两个不同的目录中了。 扩展一下，如果我们要将其分类到 Sports/Baseball 和 Play 两个不同的目录下（一个是子目录，一个是一级目录），我们该怎么写呢？如下： 123categories: - [Sports,Baseball] - [Play] 添加描述： 每天下课回宿舍的路，没有什么故事1。 指定宽度： 指定宽度并添加描述： 每天下课回宿舍的路，没有什么故事。3 设置占位背景色： 优化不同宽度浏览的观感 4 图片描述 图片描述 图片描述 Your browser does not support the video tag. 直接install hexo-asset-image是不行的， npm install https://github.com/xcodebuild/hexo-asset-image 要这样指定这个依赖的地址。 个人感觉最好的还是本地链接图片这样具有高稳定性和可移植性 12345678910111213141516Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:N6AEN8e335q6O3wd9iorUjTPa6Q0WgiiLx5Ju65m+Vo 2864674131@qq.comThe key&#x27;s randomart image is:+---[RSA 2048]----+| . o.. || o o. . || . .. . || .... .+ || .. ...Soo= . || ..o ..=.= + || =E * + * o || +oo. o = B . .||+=*o .+O.o.. |+----[SHA256]-----+ 1&lt;video src=&quot;/2022/05/18/测试/大道五号.Avenue.5.S01E09.END.中英字幕.WEBrip.720P-人人影视.mp4&quot; position= &quot;absolute&quot; width=&quot;100%&quot; height=&quot;100%&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://blog.mikuti.com/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"web后端","slug":"web前端/web后端","permalink":"http://blog.mikuti.com/categories/web%E5%89%8D%E7%AB%AF/web%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"tags","slug":"tags","permalink":"http://blog.mikuti.com/tags/tags/"},{"name":"git","slug":"git","permalink":"http://blog.mikuti.com/tags/git/"}]},{"title":"IDA快捷键","slug":"安全/二进制安全/IDA快捷键","date":"2022-05-18T15:45:06.000Z","updated":"2022-05-20T11:35:52.616Z","comments":true,"path":"2022/05/18/安全/二进制安全/IDA快捷键/","link":"","permalink":"http://blog.mikuti.com/2022/05/18/%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/IDA%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"1234567891011121314151617181920212223空格键 反汇编窗口切换文本跟图形ESC退到上一个操作地址G搜索地址或者符号N重命名分号键 注释ALT+M 添加标签CTRL+M 列出所有标签CTRL +S 二进制段的开始地址结束地址C code 光标地址出内容解析成代码P 在函数开始处使用P，从当前地址处解析成函数D data解析成数据A ASCII解析成ASCIIU unDefined解析成未定义的内容X 交叉引用F5 C伪代码菜单栏中的搜索功能中有ALT+T 搜索文本ALT+B 搜索16进制 搜索opcode 如ELF文件头打开断点列表 CTRL+ALT+B单步步入 F7单步不过 F8运行到函数返回地址 CTRL+F7运行到光标处 F4","categories":[{"name":"信息安全","slug":"信息安全","permalink":"http://blog.mikuti.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"二进制安全","slug":"信息安全/二进制安全","permalink":"http://blog.mikuti.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"tags","slug":"tags","permalink":"http://blog.mikuti.com/tags/tags/"},{"name":"git","slug":"git","permalink":"http://blog.mikuti.com/tags/git/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-05-18T13:09:14.672Z","updated":"2022-05-19T01:14:13.906Z","comments":true,"path":"2022/05/18/hello-world/","link":"","permalink":"http://blog.mikuti.com/2022/05/18/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"安全","slug":"安全","permalink":"http://blog.mikuti.com/categories/%E5%AE%89%E5%85%A8/"},{"name":"二进制安全工具","slug":"安全/二进制安全工具","permalink":"http://blog.mikuti.com/categories/%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"},{"name":"web前端","slug":"web前端","permalink":"http://blog.mikuti.com/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"web后端","slug":"web前端/web后端","permalink":"http://blog.mikuti.com/categories/web%E5%89%8D%E7%AB%AF/web%E5%90%8E%E7%AB%AF/"},{"name":"信息安全","slug":"信息安全","permalink":"http://blog.mikuti.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"},{"name":"二进制安全","slug":"信息安全/二进制安全","permalink":"http://blog.mikuti.com/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"FTP Fuzzing","slug":"FTP-Fuzzing","permalink":"http://blog.mikuti.com/tags/FTP-Fuzzing/"},{"name":"Fuzzg","slug":"Fuzzg","permalink":"http://blog.mikuti.com/tags/Fuzzg/"},{"name":"WinDbg","slug":"WinDbg","permalink":"http://blog.mikuti.com/tags/WinDbg/"},{"name":"tags","slug":"tags","permalink":"http://blog.mikuti.com/tags/tags/"},{"name":"git","slug":"git","permalink":"http://blog.mikuti.com/tags/git/"}]}